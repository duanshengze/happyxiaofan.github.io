<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="http://libs.useso.com//css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ConcurrentHashMap,HashMap,线程," />





  <link rel="alternate" href="/atom.xml" title="rhwayfun的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="最近无意中发现有很多对Map尤其是HashMap的线程安全性的话题讨论，在我的理解中，对HashMap的理解中也就知道它是线程不安全的，以及HashMap的底层算法采用了链地址法来解决哈希冲突的知识，但是对其线程安全性的认知有限，故写这篇博客的目的就是让和我对这块内容不熟悉的小伙伴有一个对HashMap更深的认知，为了让你更好的查看你感兴趣的内容，你也可以直接点击右边的文章目录进行阅读。">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析HashMap与ConcurrentHashMap的线程安全性">
<meta property="og:url" content="http://rhwayfun.com/post/HashMap-Hashtable-ConcurrentHashMap-Analysis/index.html">
<meta property="og:site_name" content="rhwayfun的博客">
<meta property="og:description" content="最近无意中发现有很多对Map尤其是HashMap的线程安全性的话题讨论，在我的理解中，对HashMap的理解中也就知道它是线程不安全的，以及HashMap的底层算法采用了链地址法来解决哈希冲突的知识，但是对其线程安全性的认知有限，故写这篇博客的目的就是让和我对这块内容不熟悉的小伙伴有一个对HashMap更深的认知，为了让你更好的查看你感兴趣的内容，你也可以直接点击右边的文章目录进行阅读。">
<meta property="og:image" content="http://7xkjk9.com1.z0.glb.clouddn.com/链地址法.jpg">
<meta property="og:updated_time" content="2016-04-15T07:01:12.667Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析HashMap与ConcurrentHashMap的线程安全性">
<meta name="twitter:description" content="最近无意中发现有很多对Map尤其是HashMap的线程安全性的话题讨论，在我的理解中，对HashMap的理解中也就知道它是线程不安全的，以及HashMap的底层算法采用了链地址法来解决哈希冲突的知识，但是对其线程安全性的认知有限，故写这篇博客的目的就是让和我对这块内容不熟悉的小伙伴有一个对HashMap更深的认知，为了让你更好的查看你感兴趣的内容，你也可以直接点击右边的文章目录进行阅读。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6266380989375710000,
      author: '博主'
    }
  };
</script>

  <title> 浅析HashMap与ConcurrentHashMap的线程安全性 | rhwayfun的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7f10cfbefe1d22997aa0dcb64b6fa286";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">rhwayfun的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">在等待的日子里，刻苦读书，谦卑做人，养得深根，日后才能枝叶茂盛！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
            读书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'XemytyRAZXbEjGGrpXE2','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                浅析HashMap与ConcurrentHashMap的线程安全性
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-04T10:27:48+08:00" content="2015-09-04">
              2015-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java集合框架/" itemprop="url" rel="index">
                    <span itemprop="name">Java集合框架</span>
                  </a>
                </span>

                
                

              
            </span>
          
          
          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/post/HashMap-Hashtable-ConcurrentHashMap-Analysis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="post/HashMap-Hashtable-ConcurrentHashMap-Analysis/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近无意中发现有很多对Map尤其是HashMap的线程安全性的话题讨论，在我的理解中，对HashMap的理解中也就知道它是线程不安全的，以及HashMap的底层算法采用了链地址法来解决哈希冲突的知识，但是对其线程安全性的认知有限，故写这篇博客的目的就是让和我对这块内容不熟悉的小伙伴有一个对HashMap更深的认知，为了让你更好的查看你感兴趣的内容，你也可以直接点击右边的文章目录进行阅读。<br><a id="more"></a></p>
<h1 id="哈希表">哈希表</h1><hr>
<p>在数据结构中有一种称为哈希表的数据结构，它实际上是数组的推广。如果有一个数组，要最有效的查找某个元素的位置，如果存储空间足够大，那么可以对每个元素和内存中的某个地址对应起来，然后把每个元素的地址用一个数组（这个数组也称为<code>哈希表</code>）存储起来，然后通过数组下标就可以直接找到某个元素了。这种方法术语叫做<code>直接寻址法</code>。这种方法的关键是要把每个元素和某个地址对应起来，所以如果当一组数据的取值范围很大的时候，而地址的空间又有限，那么必然会有多个映射到同一个地址，术语上称为<code>哈希冲突</code>，这时映射到同一个地址的元素称为<code>同义词</code>。毕竟，存储空间有限，所以冲突是不可避免的，但是可以尽量做到减少冲突。目前有两种比较有效的方法来解决哈希冲突：</p>
<ul>
<li>链地址法</li>
<li>开放地址法</li>
</ul>
<p>这里简要说明一下开放地址法，顾名思义，就是哈希表中的每个位置要么存储了一个元素要么为NULL。当数据比较多的时候，查找一个元素挺费事的，但是可以使用探测的方法进行查找。这个话题与本主题关系不大，感兴趣的小伙伴可以自行研究。</p>
<h2 id="链地址法">链地址法</h2><p>为什么要把链地址法单独拿出来呢？因为后面有用。<br>链地址法的大概思想是：对于每个关键字，使用哈希函数确定其在哈希表中位置（也就是下标），如果该位置没有元素则直接映射到该地址；如果该位置已经有元素了，就把该元素连接到已存在元素的尾部，也就是一个链表，并把该元素的next设置为null。这样的话，每个哈希表的位置都可能存在一个链表，这种方式要查找某个元素效率比较高，时间复杂度为O(1+a)，a为哈希表中每个位置链表的平均长度。这里需要假设每个元素都被等可能映射到哈希表中的任意一个位置。</p>
<p>下面这张图展示了链地址法的过程：</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/链地址法.jpg" alt="链地址法"></p>
<h1 id="HashMap">HashMap</h1><hr>
<h2 id="HashMap底层实现">HashMap底层实现</h2><p>HashMap允许使用null作为key或者value，并且HashMap不是线程安全的，除了这两点外，HashMap与Hashtable大致相同，下面是官方API对HashMap的描述：</p>
<blockquote>
<p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. </p>
</blockquote>
<p>如果有多个线程对Hash映射进行访问，那么至少有一个线程会对哈希映射进行结构的修改：</p>
<blockquote>
<p>结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改</p>
</blockquote>
<p>那么很显然，当多个线程同时（严格来说不能称为同时，因为CPU每次只能允许一个线程获取资源，只不过时间上非常短，CPU运行速度很快，所以理解为<code>同时</code>）修改哈希映射，那么最终的哈希映射（就是哈希表）的最终结果是不能确定的，这只能看CPU心情了。如果要解决这个问题，官方的参考方案是保持外部同步，什么意思？看下面的代码就知道了：</p>
<pre><code><span class="built_in">Map</span> m <span class="subst">=</span> Collections<span class="built_in">.</span>synchronizedMap(<span class="literal">new</span> HashMap(<span class="attribute">...</span>));
</code></pre><p>但是不建议这么使用，因为当多个并发的非同步操作修改哈希表的时候，最终结果不可预测，所以使用上面的方法创建HashMap的时候，当有多个线程并发访问哈希表的情况下，会抛出异常，所以并发修改会失败。比如下面这段代码：</p>
<pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 20; i++) {</span>
        collectionSynMap.put<span class="list">(<span class="keyword">i</span>, String.valueOf<span class="list">(<span class="keyword">i</span>)</span>)</span><span class="comment">;</span>
    }
    Set&lt;Entry&lt;Integer,String&gt;&gt; keySets = collectionSynMap.entrySet<span class="list">()</span><span class="comment">;</span>
    Iterator&lt;Entry&lt;Integer, String&gt;&gt; keySetsIterator = keySets.iterator<span class="list">()</span><span class="comment">;</span>
    try {
        while<span class="list">(<span class="keyword">keySetsIterator</span>.hasNext<span class="list">()</span>)</span>{
            Entry&lt;Integer,String&gt; entrys = <span class="list">(<span class="keyword">Entry&lt;Integer</span>, String&gt;)</span> keySetsIterator.next<span class="list">()</span><span class="comment">;</span>
            System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
            if<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>.equals<span class="list">(<span class="string">"1"</span>)</span>)</span>{
                System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
                collectionSynMap.remove<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span>
                //keySetsIterator.remove<span class="list">()</span><span class="comment">;</span>
            }
        }
    } catch <span class="list">(<span class="keyword">Exception</span> e)</span> {
        e.printStackTrace<span class="list">()</span><span class="comment">;</span>
    }</span>
</code></pre><p>就会抛出ConcurrentModificationException异常，因为在使用迭代器遍历的时候修改映射结构，但是使用代码中注释的删除是不会抛出异常的。</p>
<p>通过上面的分析，我们初步了解HashMap的非线程安全的原理，下面从源码的角度分析一下，为什么HashMap不是线程安全的：</p>
<pre><code><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>{
    <span class="comment">//这里省略了对重复键值的处理代码</span>
    modCount++;
    addEntry(hash, key, <span class="keyword">value</span>, i);
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>那么问题应该处在addEntry()上，下面来看看其源码：</p>
<pre><code>void addEntry<span class="params">(int hash, K key, V value, int bucketIndex)</span> {
    <span class="comment">//如果达到Map的阈值，那么就扩大哈希表的容量</span>
    <span class="keyword">if</span> <span class="params">(<span class="params">(size &gt;= threshold)</span> &amp;&amp; <span class="params">(null != table[bucketIndex])</span>)</span> {
        <span class="comment">//扩容</span>
        <span class="built_in">resize</span><span class="params">(<span class="number">2</span> * table.length)</span>;
        hash = <span class="params">(null != key)</span> ? hash<span class="params">(key)</span> : <span class="number">0</span>;
        bucketIndex = indexFor<span class="params">(hash, table.length)</span>;
    }
    <span class="comment">//创建Entry键值对，此处省略这部分代码</span>
}
</code></pre><p>假设有线程A和线程B都调用addEntry()方法，线程A和B会得到当前哈希表位置的头结点（就是上面链地址法的第一个元素），并修改该位置的头结点，如果是线程A先获取头结点，那么B的操作就会覆盖线程A的操作，所以会有问题。</p>
<p>下面再看看resize方法的源码：</p>
<pre><code>void <span class="built_in">resize</span><span class="params">(int newCapacity)</span> {
    <span class="comment">//此处省略如果达到阈值扩容为原来两倍的过程代码</span>
    Entry[] newTable = new Entry[newCapacity];
    <span class="comment">//把当前的哈希表转移到新的扩容后的哈希表中</span>
    transfer<span class="params">(newTable, initHashSeedAsNeeded<span class="params">(newCapacity)</span>)</span>;
    table = newTable;
    threshold = <span class="params">(int)</span>Math.<span class="built_in">min</span><span class="params">(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>)</span>;
}
</code></pre><p>所以如果有多个线程执行put方法，并调用resize方法，那么就会出现多种情况，在转移的过程中丢失数据，或者扩容失败，都有可能，所以从源码的角度分析这也是线程不安全的。</p>
<h2 id="HashMap测试代码">HashMap测试代码</h2><pre><code>for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 40; i++) {</span>
    hashMap.put<span class="list">(<span class="keyword">i</span>, String.valueOf<span class="list">(<span class="keyword">i</span>)</span>)</span><span class="comment">;</span>
}
Set&lt;Entry&lt;Integer,String&gt;&gt; keySets = hashMap.entrySet<span class="list">()</span><span class="comment">;</span>
final Iterator&lt;Entry&lt;Integer, String&gt;&gt; keySetsIterator = keySets.iterator<span class="list">()</span><span class="comment">;</span>
Thread t3 = new Thread<span class="list">()</span>{
    public void run<span class="list">()</span>{
        try {
            while<span class="list">(<span class="keyword">keySetsIterator</span>.hasNext<span class="list">()</span>)</span>{
                Entry&lt;Integer,String&gt; entrys = <span class="list">(<span class="keyword">Entry&lt;Integer</span>, String&gt;)</span> keySetsIterator.next<span class="list">()</span><span class="comment">;</span>
                System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
                if<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>.equals<span class="list">(<span class="string">"1"</span>)</span>)</span>{
                    System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
                    hashMap.remove<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span>
                }
            }
        } catch <span class="list">(<span class="keyword">Exception</span> e)</span> {
            e.printStackTrace<span class="list">()</span><span class="comment">;</span>
        }
    }
}<span class="comment">;</span>
Thread t4 = new Thread<span class="list">()</span>{
    public void run<span class="list">()</span>{
        try {
            while<span class="list">(<span class="keyword">keySetsIterator</span>.hasNext<span class="list">()</span>)</span>{
                Entry&lt;Integer,String&gt; entrys = <span class="list">(<span class="keyword">Entry&lt;Integer</span>, String&gt;)</span> keySetsIterator.next<span class="list">()</span><span class="comment">;</span>
                System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
                if<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>.equals<span class="list">(<span class="string">"1"</span>)</span>)</span>{
                    System.out.println<span class="list">(<span class="keyword">entrys</span>.getValue<span class="list">()</span>)</span><span class="comment">;</span>
                    hashMap.remove<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span>
                }
            }
        } catch <span class="list">(<span class="keyword">Exception</span> e)</span> {
            e.printStackTrace<span class="list">()</span><span class="comment">;</span>
        }
    }
}<span class="comment">;</span>
t3.start<span class="list">()</span><span class="comment">;</span>
t4.start<span class="list">()</span><span class="comment">;</span></span>
</code></pre><p>这段代码启动了两个线程并发修改HashMap的映射关系，所以会抛出两个ConcurrentModificationException异常，通过这段测试代码在此证明了HashMap的非线程安全。</p>
<h1 id="Hashtable和ConcurrentHashMap">Hashtable和ConcurrentHashMap</h1><hr>
<h2 id="Hashtable的底层实现">Hashtable的底层实现</h2><p>在介绍HashMap提到Hashtable是线程安全的，那么H啊时table是如何实现线程安全的呢？有了上面的介绍，我们直接从源码中分析其线程安全性：</p>
<pre><code><span class="keyword">public</span> synchronized V put(K key, V value) {
    <span class="comment">// 保证value值不为空，此处省略其代码</span>
    <span class="comment">// 保证key是不重复的，此处省略其代码</span>
    <span class="comment">//查过阈值则扩容，此处省略</span>
    <span class="comment">// Creates the new entry.</span>
    Entry&lt;K,V&gt; e = tab[<span class="keyword">index</span>];
    tab[<span class="keyword">index</span>] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);
    <span class="keyword">count</span>++;
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>通过源码可以很明显看到其put方法使用synchronized关键字，在线程中这是实现线程安全的一种方式，所以Hashtable是线程安全的。</p>
<h2 id="Hashtable的测试案例">Hashtable的测试案例</h2><p>下面使用一段测试代码验证Hashtable的线程安全：</p>
<pre><code>Thread t3 = new Thread<span class="params">()</span>{
        public void run<span class="params">()</span>{
            <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span> {
                hashTable.put<span class="params">(i, String.valueOf<span class="params">(i)</span>)</span>;
            }
        }
    };
    Thread t4 = new Thread<span class="params">()</span>{
        public void run<span class="params">()</span>{
            <span class="keyword">for</span> <span class="params">(int i = <span class="number">20</span>; i &lt; <span class="number">40</span>; i++)</span> {
                hashTable.put<span class="params">(i, String.valueOf<span class="params">(i)</span>)</span>;
            }
        }
    };
    t3.start<span class="params">()</span>;
    t4.start<span class="params">()</span>;
    <span class="comment">//放完数据后，从map中取出数据，如果map是线程安全的，那么取出的entry应该和放进去的一一对应</span>
    <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span> {
        System.out.println<span class="params">(i + <span class="string">"="</span> + hashTable.get<span class="params">(i)</span>)</span>;
    }
</code></pre><p>最后得到的输出结果是这样的：</p>
<pre><code>![<span class="link_label">Hashtable</span>](<span class="link_url">http://7xkjk9.com1.z0.glb.clouddn.com/ConcurrentHashMap_put结果.jpg</span>)
</code></pre><p>OK，再次说明Hashtable是线程安全的。</p>
<h2 id="ConcurrentHashMap的底层实现">ConcurrentHashMap的底层实现</h2><p>ConcurrentHashMap支持完全并发的对哈希表的操作，ConcurrentHashMap遵从了和Hashtable一样的规范，这里指的是线程安全的规范，但是其底层的实现与Hashtable并不一致。ConcurrentHashMap底层采用的锁机制，执行put方法的线程会获得锁，只有当此线程的put方法执行结束后才会释放锁，根据多线程的知识，获得锁的线程会通知其他试图操作put方法的线程，并通知其他线程出于等待状态，直到释放锁后，其他线程才会去重新竞争锁。这一点保证了ConcurrentHashMap的线程安全。</p>
<p>注：这里涉及到了线程锁的知识，如果对这块内容不熟悉，可以参考API。<br>引用一段官方API对ConcurrentHashMap的描述：</p>
<blockquote>
<p>A hash table supporting full concurrency of retrievals and adjustable expected concurrency for updates. This class obeys the same functional specification as Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details. </p>
</blockquote>
<p>从这段描述可以看出，ConcurrentHashMap实际上是Hashtable的升级版，除了具备线程安全外还增加了迭代器快速失败行为的异常处理，也就是说，通过ConcurrentHashMap对Iterator迭代器结构的修改不会抛出异常，而Hashtable会抛出异常，因而就Hashtable来说，如果迭代器修改了映射结构，那么遍历的结果是不确定的，而ConcurrentHashmap支持之允许一个线程对迭代器的映射结构进行修改。</p>
<p>那么我们接着从源码的角度分析ConcurrentHashMap是如何实现线程安全的：</p>
<pre><code><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>{
    Segment&lt;K,V&gt; s;
    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    <span class="keyword">int</span> hash = hash(key);
    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span>
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span>
        s = ensureSegment(j);
    <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="keyword">false</span>);
}
</code></pre><p>ConcurrentHashMap把要放入的数据分成了多段数据，然后对每段的put操作进行加锁，下面看一下ensureSegment方法：</p>
<pre><code>private Segment&lt;K,V&gt; ensureSegment<span class="params">(int k)</span> {
    final Segment&lt;K,V&gt;[] ss = this.segments;
    long u = <span class="params">(k &lt;&lt; SSHIFT)</span> + SBASE; <span class="comment">// raw offset</span>
    Segment&lt;K,V&gt; seg;
    <span class="keyword">if</span> <span class="params">(<span class="params">(seg = <span class="params">(Segment&lt;K,V&gt;)</span>UNSAFE.getObjectVolatile<span class="params">(ss, u)</span>)</span> == null)</span> {
        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span>
        int cap = proto.table.length;
        float lf = proto.loadFactor;
        int threshold = <span class="params">(int)</span><span class="params">(cap * lf)</span>;
        HashEntry&lt;K,V&gt;[] tab = <span class="params">(HashEntry&lt;K,V&gt;[])</span>new HashEntry[cap];
        <span class="keyword">if</span> <span class="params">(<span class="params">(seg = <span class="params">(Segment&lt;K,V&gt;)</span>UNSAFE.getObjectVolatile<span class="params">(ss, u)</span>)</span>
            == null)</span> { <span class="comment">// recheck</span>
            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;<span class="params">(lf, threshold, tab)</span>;
            while <span class="params">(<span class="params">(seg = <span class="params">(Segment&lt;K,V&gt;)</span>UNSAFE.getObjectVolatile<span class="params">(ss, u)</span>)</span>
                   == null)</span> {
                <span class="keyword">if</span> <span class="params">(UNSAFE.compareAndSwapObject<span class="params">(ss, u, null, seg = s)</span>)</span>
                    break;
            }
        }
    }
    return seg;
}
</code></pre><p>这段代码的作用就是根据给定的索引，返回某个具体的Segment，然后根据返回的Segment（块）加锁执行put方法。<br>再看s.put()方法：</p>
<pre><code><span class="keyword">final</span> <span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{
        HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :
            scanAndLockForPut(key, hash, value);
        V oldValue;
        <span class="keyword">try</span> {
            <span class="comment">//此处省略详细的处理过程</span>
            }
        } <span class="keyword">finally</span> {
            unlock();
        }
        <span class="keyword">return</span> oldValue;
    }
</code></pre><p>在上面的源码中出现了Segment<k,v> s，我们来看看它何方神圣：</k,v></p>
<blockquote>
<p>Segments are specialized versions of hash tables.  This subclasses from ReentrantLock opportunistically, just tosimplify some locking and avoid separate construction.</p>
</blockquote>
<p>从这段注释中可以发现每次执行ConcurrentHashMap的put方法都是调用s.put()方法的，而Segments对象是一个继承了ReentrantLock锁对象的子类，那么剩下的就很清晰了，每一个Segments都有一个锁，只有执行完上面try语句块中的代码才会释放锁，从而保证了多线程并发访问的安全性。</p>
<p>下面来看看ConcurrentHashMap的get方法：</p>
<pre><code>public V get<span class="params">(Object key)</span> {
    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span>
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash<span class="params">(key)</span>;
    long u = <span class="params">(<span class="params">(<span class="params">(h &gt;&gt;&gt; segmentShift)</span> &amp; segmentMask)</span> &lt;&lt; SSHIFT)</span> + SBASE;
    <span class="keyword">if</span> <span class="params">(<span class="params">(s = <span class="params">(Segment&lt;K,V&gt;)</span>UNSAFE.getObjectVolatile<span class="params">(segments, u)</span>)</span> != null &amp;&amp;
        <span class="params">(tab = s.table)</span> != null)</span> {
        <span class="keyword">for</span> <span class="params">(HashEntry&lt;K,V&gt; e = <span class="params">(HashEntry&lt;K,V&gt;)</span> UNSAFE.getObjectVolatile
                 <span class="params">(tab, <span class="params">(<span class="params">(long)</span><span class="params">(<span class="params">(<span class="params">(tab.length - <span class="number">1</span>)</span> &amp; h)</span>)</span> &lt;&lt; TSHIFT)</span> + TBASE)</span>;
             e != null; e = e.next)</span> {
            K k;
            <span class="keyword">if</span> <span class="params">(<span class="params">(k = e.key)</span> == key || <span class="params">(e.hash == h &amp;&amp; key.equals<span class="params">(k)</span>)</span>)</span>
                return e.value;
        }
    }
    return null;
}
</code></pre><p>get操作会通过key找到哈希表的哈希值，根据哈希值定位到某个Segment，然后再从Segment中返回value</p>
<h2 id="ConcurrentHashMap的测试案例">ConcurrentHashMap的测试案例</h2><p>下面仍然通过一段测试程序验证ConcurrentHashMap的线程安全：</p>
<pre><code>Thread t5 = new Thread<span class="params">()</span>{
        public void run<span class="params">()</span>{
            <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span> {
                concurrentHashMap.put<span class="params">(i, String.valueOf<span class="params">(i)</span>)</span>;
            }
        }
    };
    Thread t6 = new Thread<span class="params">()</span>{
        public void run<span class="params">()</span>{
            <span class="keyword">for</span> <span class="params">(int i = <span class="number">20</span>; i &lt; <span class="number">40</span>; i++)</span> {
                concurrentHashMap.put<span class="params">(i, String.valueOf<span class="params">(i)</span>)</span>;
            }
        }
    };
    t5.start<span class="params">()</span>;
    t6.start<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span> {
        System.out.println<span class="params">(i + <span class="string">"="</span> + concurrentHashMap.get<span class="params">(i)</span>)</span>;
    }
</code></pre><p>最后，控制台输出的结果如下：</p>
<pre><code>![<span class="link_label">ConcurrentHashMap</span>](<span class="link_url">http://7xkjk9.com1.z0.glb.clouddn.com/ConcurrentHashMap_put结果.jpg</span>)
</code></pre><h1 id="小结">小结</h1><hr>
<p>说了那么多，针对Map子类的安全性可以总结如下几点：</p>
<ul>
<li>HashMap采用链地址法解决哈希冲突，多线程访问哈希表的位置并修改映射关系的时候，后执行的线程会覆盖先执行线程的修改，所以不是线程安全的</li>
<li>Hashtable采用synchronized关键字解决了并发访问的安全性问题但是效率较低</li>
<li>ConcurrentHashMap使用了线程锁分段技术，每次访问只允许一个线程修改哈希表的映射关系，所以是线程安全的</li>
</ul>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
<div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton", disable="enable", onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}", style="cursor: pointer; border: 0; outline: 0; border-radius: 100%; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0px; text-shadow: none">
    <span onmouseover="this.style.color='rgb(236,96,0)';this.style.background='rgb(204,204,204)'" onMouseOut="this.style.color='#fff';this.style.background='rgb(236,96,0)'" style="display: inline-block; width: 70px; height: 70px; border-radius: 100%; line-height: 81px; color: #fff; font: 400 35px/75px 'microsofty'; background: rgb(236,96,0)">赏</span>
  </button>
  <div id="QR" style="display: none;">
    
    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="rhwayfun Alipay" style="width: 200px; max-width: 100%; display: inline-block"/>
        <p>支付宝打赏</p>
      </div>
    
  </div>
</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ConcurrentHashMap/" rel="tag">#ConcurrentHashMap</a>
          
            <a href="/tags/HashMap/" rel="tag">#HashMap</a>
          
            <a href="/tags/线程/" rel="tag">#线程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/springmvc-notes-1/" rel="next" title="springmvc学习笔记">
                <i class="fa fa-chevron-left"></i> springmvc学习笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/ArrayList-LinkedList-source-code/" rel="prev" title="ArrayList与LinkedList源码分析">
                ArrayList与LinkedList源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="post/HashMap-Hashtable-ConcurrentHashMap-Analysis/"
     data-title="浅析HashMap与ConcurrentHashMap的线程安全性"
     data-content=""
     data-url="http://rhwayfun.com/post/HashMap-Hashtable-ConcurrentHashMap-Analysis/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="post/HashMap-Hashtable-ConcurrentHashMap-Analysis/"
           data-title="浅析HashMap与ConcurrentHashMap的线程安全性" data-url="http://rhwayfun.com/post/HashMap-Hashtable-ConcurrentHashMap-Analysis/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="rhwayfun" />
          <p class="site-author-name" itemprop="name">rhwayfun</p>
          <p class="site-description motion-element" itemprop="description">在等待的日子里，刻苦读书，谦卑做人，养得深根，日后才能枝叶茂盛！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">150</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/happyxiaofan" target="_blank" title="Github">
                  
                    <i class="fa fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/rhwayfun" target="_blank" title="微博">
                  
                    <i class="fa fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/rhwayfun" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/rhwayfun" target="_blank" title="知乎">
                  
                    <i class="fa fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element">
            <div class="links-of-blogroll-title">
              <i class="fa fa-globe fa-fw"></i>
              我的驻点
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/u011116672" title="CSDN" target="_blank">CSDN</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ifeve.com" title="并发编程网" target="_blank">并发编程网</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希表"><span class="nav-number">1.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链地址法"><span class="nav-number">1.1.</span> <span class="nav-text">链地址法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap"><span class="nav-number">2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap底层实现"><span class="nav-number">2.1.</span> <span class="nav-text">HashMap底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap测试代码"><span class="nav-number">2.2.</span> <span class="nav-text">HashMap测试代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hashtable和ConcurrentHashMap"><span class="nav-number">3.</span> <span class="nav-text">Hashtable和ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtable的底层实现"><span class="nav-number">3.1.</span> <span class="nav-text">Hashtable的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtable的测试案例"><span class="nav-number">3.2.</span> <span class="nav-text">Hashtable的测试案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap的底层实现"><span class="nav-number">3.3.</span> <span class="nav-text">ConcurrentHashMap的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap的测试案例"><span class="nav-number">3.4.</span> <span class="nav-text">ConcurrentHashMap的测试案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rhwayfun</span>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv">本站访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"rhwayfun"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  

</body>
</html>
